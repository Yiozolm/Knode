<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knode - 知识节点系统</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

    <!-- Code highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- Markdown and LaTeX rendering libraries -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <!-- Additional fonts for better rendering -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            line-height: 1.6;
        }

        .app {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header h1 i {
            color: #667eea;
        }

        .main-container {
            display: flex;
            gap: 20px;
            height: calc(100vh - 160px);
        }

        .sidebar {
            width: 300px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
        }

        .model-selector {
            margin-bottom: 20px;
        }

        .model-selector label {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-weight: 500;
        }

        .model-selector select {
            width: 100%;
            padding: 8px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
        }

        .system-msg {
            margin-bottom: 20px;
        }

        .system-msg label {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-weight: 500;
        }

        .system-msg textarea {
            width: 100%;
            padding: 8px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            resize: vertical;
            min-height: 80px;
        }

        .init-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: transform 0.2s;
        }

        .init-btn:hover {
            transform: translateY(-2px);
        }

        .init-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .tree-container {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        .input-container {
            margin-top: 20px;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .input-group input {
            flex: 1;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
        }

        .input-group button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: transform 0.2s;
        }

        .input-group button:hover {
            transform: translateY(-2px);
        }

        .input-group button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .tree {
            margin-top: 20px;
        }

        .node {
            margin-bottom: 20px;
            border: 2px solid #e1e5e9;
            border-radius: 12px;
            padding: 15px;
            background: white;
            transition: all 0.3s ease;
        }

        .node:hover {
            border-color: #667eea;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.1);
        }

        .node.question {
            border-left: 4px solid #667eea;
        }

        .node.answer {
            border-left: 4px solid #48bb78;
        }

        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .node-type {
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .node-type.question {
            color: #667eea;
        }

        .node-type.answer {
            color: #48bb78;
        }

        .node-actions {
            display: flex;
            gap: 10px;
        }

        .node-action-btn {
            background: none;
            border: none;
            color: #718096;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .node-action-btn:hover {
            background: #f7fafc;
            color: #667eea;
        }

        .node-content {
            color: #4a5568;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .node-children {
            margin-left: 20px;
            margin-top: 15px;
            border-left: 2px solid #e1e5e9;
            padding-left: 20px;
        }

        .token-info {
            font-size: 12px;
            color: #718096;
            margin-top: 8px;
        }

        .status {
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
        }

        .status.info {
            background: #e6fffa;
            color: #0284c7;
            border: 1px solid #99f6e4;
        }

        .status.success {
            background: #f0fdf4;
            color: #16a34a;
            border: 1px solid #bbf7d0;
        }

        .status.error {
            background: #fef2f2;
            color: #dc2626;
            border: 1px solid #fecaca;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: #667eea;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #e1e5e9;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .empty-state {
            text-align: center;
            color: #718096;
            padding: 40px;
        }

        .empty-state i {
            font-size: 48px;
            color: #e1e5e9;
            margin-bottom: 15px;
        }

        /* Rich content rendering styles */
        .node-content {
            color: #4a5568;
            line-height: 1.7;
        }

        /* Markdown elements */
        .node-content h1, .node-content h2, .node-content h3,
        .node-content h4, .node-content h5, .node-content h6 {
            margin: 16px 0 8px 0;
            color: #2d3748;
            font-weight: 600;
        }

        .node-content h1 { font-size: 1.8em; }
        .node-content h2 { font-size: 1.5em; }
        .node-content h3 { font-size: 1.3em; }
        .node-content h4 { font-size: 1.1em; }

        .node-content p {
            margin: 8px 0;
        }

        .node-content ul, .node-content ol {
            margin: 8px 0 8px 24px;
        }

        .node-content li {
            margin: 4px 0;
        }

        .node-content strong, .node-content b {
            color: #2d3748;
            font-weight: 600;
        }

        .node-content em, .node-content i {
            color: #4a5568;
            font-style: italic;
        }

        /* Code blocks */
        .node-content code {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 2px 6px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
            color: #d53f8c;
        }

        .node-content pre {
            background: #2d3748;
            border-radius: 8px;
            padding: 16px;
            overflow-x: auto;
            margin: 12px 0;
            position: relative;
        }

        .node-content pre code {
            background: none;
            border: none;
            padding: 0;
            color: #e2e8f0;
            font-size: 0.9em;
            line-height: 1.5;
        }

        /* Language tags for code blocks */
        .node-content pre[data-language]::before {
            content: attr(data-language);
            position: absolute;
            top: 8px;
            right: 8px;
            background: #4a5568;
            color: #e2e8f0;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            text-transform: lowercase;
        }

        /* LaTeX/KaTeX styles */
        .node-content .katex {
            font-size: 1.1em;
        }

        .node-content .katex-display {
            margin: 16px 0;
            text-align: center;
        }

        /* Blockquotes */
        .node-content blockquote {
            border-left: 4px solid #667eea;
            background: #f8faff;
            padding: 12px 16px;
            margin: 12px 0;
            border-radius: 0 8px 8px 0;
            color: #4a5568;
        }

        /* Tables */
        .node-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 12px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .node-content th, .node-content td {
            border: 1px solid #e2e8f0;
            padding: 12px;
            text-align: left;
        }

        .node-content th {
            background: #f8faff;
            font-weight: 600;
            color: #2d3748;
        }

        .node-content tr:nth-child(even) {
            background: #f8fafc;
        }

        /* Horizontal rules */
        .node-content hr {
            border: none;
            border-top: 2px solid #e2e8f0;
            margin: 20px 0;
        }

        /* Links */
        .node-content a {
            color: #667eea;
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }

        .node-content a:hover {
            border-bottom-color: #667eea;
        }

        /* Inline math */
        .node-content .math-inline {
            background: #f8faff;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #e6efff;
        }

        /* Math error handling */
        .math-error {
            background: #fed7d7;
            border: 1px solid #fc8181;
            color: #c53030;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
        }

        /* Render error handling */
        .render-error {
            background: #fef5e7;
            border: 1px solid #f9e79f;
            border-radius: 6px;
            padding: 12px;
            margin: 8px 0;
        }

        .render-error p {
            margin: 0 0 8px 0;
            color: #7d6608;
        }

        .render-error pre {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 8px;
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #495057;
            font-size: 0.85em;
        }

        /* Loading spinner for content rendering */
        .content-rendering {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #e1e5e9;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 8px;
        }

        /* Conversation management styles */
        .conversation-section {
            margin-top: 20px;
            border-top: 1px solid #e2e8f0;
            padding-top: 20px;
        }

        .conversation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .conversation-header h3 {
            font-size: 16px;
            color: #2d3748;
            margin: 0;
        }

        .toggle-conversations-btn {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .toggle-conversations-btn:hover {
            background: #f8faff;
        }

        .conversation-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: #f8fafc;
        }

        .conversation-item {
            padding: 12px;
            border-bottom: 1px solid #e2e8f0;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .conversation-item:last-child {
            border-bottom: none;
        }

        .conversation-item:hover {
            background: #e6fffa;
        }

        .conversation-item.active {
            background: #f0f9ff;
            border-left: 3px solid #667eea;
        }

        .conversation-info {
            flex: 1;
            min-width: 0;
        }

        .conversation-title {
            font-weight: 500;
            color: #2d3748;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .conversation-meta {
            font-size: 12px;
            color: #718096;
            margin-top: 4px;
        }

        .conversation-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .conversation-item:hover .conversation-actions {
            opacity: 1;
        }

        .conversation-action-btn {
            background: none;
            border: none;
            color: #718096;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 12px;
        }

        .conversation-action-btn:hover {
            background: #e2e8f0;
            color: #dc2626;
        }

        .conversation-action-btn.load:hover {
            color: #667eea;
        }

        .empty-conversations {
            text-align: center;
            color: #718096;
            padding: 20px;
            font-size: 14px;
        }

        .conversation-title-input {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid #667eea;
            border-radius: 4px;
            font-size: 14px;
            margin-right: 8px;
        }

        .conversation-title-section {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .edit-title-btn {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            padding: 2px;
            border-radius: 2px;
        }

        .edit-title-btn:hover {
            background: #f0f9ff;
        }

        .save-title-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .save-title-btn:hover {
            background: #5a67d8;
        }

        .cancel-edit-btn {
            background: #e2e8f0;
            color: #4a5568;
            border: none;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 4px;
        }

        .cancel-edit-btn:hover {
            background: #cbd5e0;
        }

        /* Text selection and tooltip styles */
        .node-content {
            user-select: text;
            position: relative;
        }

        .node-content ::selection {
            background: rgba(102, 126, 234, 0.3);
        }

        .node-content ::-moz-selection {
            background: rgba(102, 126, 234, 0.3);
        }

        .selection-tooltip {
            position: absolute;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
            animation: tooltipFadeIn 0.2s ease-out;
        }

        @keyframes tooltipFadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .selection-tooltip:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.2);
        }

        .selection-tooltip::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid #764ba2;
        }

        .selection-tooltip i {
            margin-right: 4px;
        }

        .selection-highlight {
            background: rgba(102, 126, 234, 0.2);
            border-left: 3px solid #667eea;
            padding: 2px 4px;
            margin: 2px 0;
            border-radius: 0 4px 4px 0;
            position: relative;
        }

        /* Ensure links in content are still clickable */
        .node-content a {
            position: relative;
            z-index: 1;
        }

        /* Prevent tooltip from interfering with code highlighting */
        .node-content pre ::selection {
            background: rgba(102, 126, 234, 0.5);
        }

        .node-content code ::selection {
            background: rgba(102, 126, 234, 0.5);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // API 服务
        const api = {
            async initAgent(systemMsg, modelId, newConversation = true) {
                const response = await fetch('/api/init', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ system_msg: systemMsg, model_id: modelId, new_conversation: newConversation })
                });
                return response.json();
            },

            async chat(message, parentId = null) {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message, parent_id: parentId })
                });
                return response.json();
            },

            async resetAgent() {
                const response = await fetch('/api/reset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                return response.json();
            },

            // Conversation management APIs
            async getConversations() {
                const response = await fetch('/api/conversations');
                return response.json();
            },

            async getConversation(conversationId) {
                const response = await fetch(`/api/conversations/${conversationId}`);
                return response.json();
            },

            async loadConversation(conversationId) {
                const response = await fetch(`/api/conversations/${conversationId}/load`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                return response.json();
            },

            async deleteConversation(conversationId) {
                const response = await fetch(`/api/conversations/${conversationId}`, {
                    method: 'DELETE'
                });
                return response.json();
            },

            async updateConversationTitle(conversationId, title) {
                const response = await fetch(`/api/conversations/${conversationId}/title`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title })
                });
                return response.json();
            },

            async searchConversations(query) {
                const response = await fetch(`/api/conversations/search?q=${encodeURIComponent(query)}`);
                return response.json();
            }
        };

        // 富文本内容渲染工具
        const ContentRenderer = {
            // 初始化 marked.js
            initMarked() {
                if (typeof marked !== 'undefined' && !this._isInitialized) {
                    this._isInitialized = true;

                    // 设置 marked.js 配置
                    marked.setOptions({
                        breaks: true,  // 支持换行
                        gfm: true,     // GitHub Flavored Markdown
                        tables: true,
                        sanitize: false,
                        smartLists: true,
                        smartypants: true,
                        sanitize: false,
                        pedantic: false,
                        silent: false,
                        highlight: function(code, lang) {
                            // 处理 marked.js Token 对象
                            if (typeof code === 'object' && code !== null) {
                                if (code.text) {
                                    code = code.text;
                                } else if (code.raw) {
                                    code = code.raw;
                                } else {
                                    code = String(code);
                                }
                            }

                            // 确保 code 是字符串类型
                            if (typeof code !== 'string') {
                                console.warn('Highlight function received non-string code:', typeof code, code);
                                code = String(code || '');
                            }

                            // 确保 lang 是字符串类型
                            if (typeof lang !== 'string') {
                                lang = String(lang || '');
                            }

                            try {
                                if (lang && hljs.getLanguage(lang)) {
                                    return hljs.highlight(code, { language: lang }).value;
                                } else {
                                    return hljs.highlightAuto(code).value;
                                }
                            } catch (e) {
                                console.warn('Highlight error:', e);
                                try {
                                    return hljs.highlightAuto(code).value;
                                } catch (fallbackError) {
                                    console.warn('Fallback highlighting failed:', fallbackError);
                                    return code; // 返回原始代码
                                }
                            }
                        }
                    });

                    // 自定义代码块渲染器
                    const renderer = new marked.Renderer();

                    renderer.code = function(code, language) {
                        // 处理 marked.js Token 对象
                        if (typeof code === 'object' && code !== null) {
                            if (code.text) {
                                code = code.text;
                            } else if (code.raw) {
                                code = code.raw;
                            } else {
                                code = String(code);
                            }
                        }

                        // 确保 code 是字符串类型
                        if (typeof code !== 'string') {
                            console.warn('Code renderer received non-string code:', typeof code, code);
                            code = String(code || '');
                        }

                        // 确保 language 是字符串类型
                        if (typeof language !== 'string') {
                            language = String(language || 'plaintext');
                        }

                        const validLanguage = language && hljs.getLanguage(language) ? language : 'plaintext';
                        let highlighted;

                        try {
                            if (validLanguage !== 'plaintext' && hljs.getLanguage(validLanguage)) {
                                highlighted = hljs.highlight(code, { language: validLanguage }).value;
                            } else {
                                highlighted = hljs.highlightAuto(code).value;
                            }
                        } catch (e) {
                            console.warn('Code highlighting error:', e);
                            try {
                                highlighted = hljs.highlightAuto(code).value;
                            } catch (fallbackError) {
                                console.warn('Fallback highlighting also failed:', fallbackError);
                                highlighted = code; // 使用原始代码作为最后的后备
                            }
                        }

                        // 确保 highlighted 是字符串
                        if (typeof highlighted !== 'string') {
                            highlighted = String(highlighted || code);
                        }

                        return `<pre data-language="${validLanguage}"><code class="hljs">${highlighted}</code></pre>`;
                    };

                    // 自定义内联代码渲染器
                    renderer.codespan = function(code) {
                        // 处理 marked.js Token 对象
                        if (typeof code === 'object' && code !== null) {
                            if (code.text) {
                                code = code.text;
                            } else if (code.raw) {
                                code = code.raw;
                            } else {
                                code = String(code);
                            }
                        }

                        // 确保 code 是字符串类型并清理
                        if (typeof code !== 'string') {
                            console.warn('Codespan renderer received non-string code:', typeof code, code);
                            code = String(code || '');
                        }

                        // 移除可能的反引号
                        code = code.replace(/^`|`$/g, '');

                        return `<code>${code}</code>`;
                    };

                    marked.use({ renderer });
                    console.log('Marked initialized successfully');
                } else if (typeof marked === 'undefined') {
                    console.error('Marked library not loaded');
                }
            },

            // 渲染 Markdown 内容
            renderMarkdown(content) {
                // 确保 marked 已初始化
                this.initMarked();

                if (typeof marked === 'undefined') {
                    console.error('Marked library is not available');
                    return `<p style="color: red; background: #fee; padding: 8px; border-radius: 4px;">Markdown 渲染库未加载</p><pre>${String(content || '')}</pre>`;
                }

                // 确保 content 是字符串类型
                if (typeof content !== 'string') {
                    console.warn('renderMarkdown received non-string content:', typeof content, content);
                    content = String(content || '');
                }

                try {
                    console.log('Starting markdown rendering for content:', content?.substring(0, 100) + '...');

                    // 先处理 LaTeX 数学公式
                    const processedContent = this.processLatex(content);
                    console.log('LaTeX processing completed');

                    // 渲染 Markdown
                    const html = marked.parse(processedContent);

                    // 确保 html 是字符串类型
                    if (typeof html !== 'string') {
                        console.error('Marked returned non-string result:', typeof html, html);
                        return `<div class="render-error"><p>Markdown 渲染返回了非字符串结果</p><pre>${content}</pre></div>`;
                    }

                    // 检查是否包含 [object Object]
                    if (html.includes('[object Object]')) {
                        console.warn('Found [object Object] in rendered HTML, attempting to fix...');
                        // 替换所有的 [object Object] 为更友好的提示
                        const fixedHtml = html.replace(/\[object Object\]/g, '<span class="math-error">数学公式渲染错误</span>');
                        console.log('Fixed [object Object] issues');
                        return fixedHtml;
                    }

                    console.log('Markdown rendered successfully, length:', html.length);
                    return html;
                } catch (error) {
                    console.error('Markdown rendering error:', error);
                    return `<div class="render-error"><p style="color: red; background: #fee; padding: 8px; border-radius: 4px;">Markdown 渲染错误: ${error.message}</p><pre>${content}</pre></div>`;
                }
            },

            // 处理 LaTeX 数学公式
            processLatex(content) {
                // 检查 KaTeX 是否已加载
                if (typeof katex === 'undefined') {
                    console.warn('KaTeX not loaded, skipping LaTeX processing');
                    return content;
                }

                console.log('Processing LaTeX in content:', content?.substring(0, 100) + '...');

                try {
                    let processedContent = content;

                    // 处理块级数学公式 $$...$$
                    processedContent = processedContent.replace(/\$\$([^$]+)\$\$/g, (match, formula) => {
                        console.log('Processing block formula:', formula);
                        try {
                            const formulaTrimmed = formula.trim();
                            console.log('KaTeX available:', typeof katex !== 'undefined');

                            if (typeof katex === 'undefined' || !katex.renderToString) {
                                console.error('KaTeX or renderToString not available');
                                return `<div class="katex-display">$$${formulaTrimmed}$$</div>`;
                            }

                            const result = katex.renderToString(formulaTrimmed, {
                                displayMode: true,
                                throwOnError: false,
                                errorColor: '#cc0000'
                            });

                            console.log('KaTeX result type:', typeof result);
                            console.log('KaTeX result:', result?.substring(0, 100));

                            // 确保返回的是字符串
                            if (typeof result === 'string') {
                                // 检查结果中是否包含 [object Object]
                                if (result.includes('[object Object]')) {
                                    console.warn('KaTeX result contains [object Object], using fallback');
                                    return `<div class="katex-display">$$${formulaTrimmed}$$</div>`;
                                }
                                return result;
                            } else {
                                console.warn('KaTeX returned non-string for block formula:', typeof result, result);
                                return `<div class="katex-display">$$${formulaTrimmed}$$</div>`;
                            }
                        } catch (e) {
                            console.warn('KaTeX block formula error:', e);
                            return `<div class="math-error">LaTeX 错误: ${formula.trim()}</div>`;
                        }
                    });

                    // 处理内联数学公式 $...$（简化正则表达式，避免使用否定查找）
                    processedContent = processedContent.replace(/\$([^$\n]+)\$/g, (match, formula, offset, fullText) => {
                        // 检查是否是块级公式的一部分
                        const before = fullText.substring(0, offset);
                        const after = fullText.substring(offset + match.length);

                        // 如果前面或后面有 $，说明是块级公式，跳过
                        if (before.endsWith('$') || after.startsWith('$')) {
                            return match;
                        }

                        console.log('Processing inline formula:', formula);
                        try {
                            const formulaTrimmed = formula.trim();

                            if (typeof katex === 'undefined' || !katex.renderToString) {
                                console.error('KaTeX or renderToString not available');
                                return `$${formulaTrimmed}$`;
                            }

                            const result = katex.renderToString(formulaTrimmed, {
                                displayMode: false,
                                throwOnError: false,
                                errorColor: '#cc0000'
                            });

                            console.log('KaTeX inline result type:', typeof result);

                            // 确保返回的是字符串
                            if (typeof result === 'string') {
                                // 检查结果中是否包含 [object Object]
                                if (result.includes('[object Object]')) {
                                    console.warn('KaTeX inline result contains [object Object], using fallback');
                                    return `$${formulaTrimmed}$`;
                                }
                                return result;
                            } else {
                                console.warn('KaTeX returned non-string for inline formula:', typeof result, result);
                                return `$${formulaTrimmed}$`;
                            }
                        } catch (e) {
                            console.warn('KaTeX inline formula error:', e);
                            return `<span class="math-error">LaTeX 错误: ${formula.trim()}</span>`;
                        }
                    });

                    console.log('LaTeX processing completed');
                    return processedContent;
                } catch (error) {
                    console.error('LaTeX processing error:', error);
                    return content;
                }
            },

            // 渲染内容并处理数学公式
            async renderContent(content, containerElement) {
                try {
                    console.log('Starting content rendering for:', content?.substring(0, 50) + '...');

                    // 渲染 Markdown
                    const html = this.renderMarkdown(content);

                    // 设置 HTML
                    containerElement.innerHTML = html;

                    // 重新高亮代码块
                    if (typeof hljs !== 'undefined') {
                        try {
                            containerElement.querySelectorAll('pre code').forEach((block) => {
                                hljs.highlightElement(block);
                            });
                        } catch (error) {
                            console.warn('Code highlighting error:', error);
                        }
                    }

                    // 渲染剩余的数学公式（如果 KaTeX auto-render 可用）
                    if (typeof renderMathInElement !== 'undefined' && typeof katex !== 'undefined') {
                        try {
                            renderMathInElement(containerElement, {
                                delimiters: [
                                    {left: '$$', right: '$$', display: true},
                                    {left: '$', right: '$', display: false}
                                ],
                                throwOnError: false,
                                strict: false
                            });
                            console.log('KaTeX auto-render completed');
                        } catch (error) {
                            console.warn('KaTeX auto-render error:', error);
                        }
                    }

                    console.log('Content rendering completed successfully');
                } catch (error) {
                    console.error('Content rendering error:', error);
                    containerElement.innerHTML = `<div style="color: red; background: #fee; padding: 8px; border-radius: 4px;">内容渲染错误: ${error.message}</div><pre>${content}</pre>`;
                }
            }
        };

        // React 组件用于渲染富内容，支持文本选择
        const RichContentRenderer = ({ content, nodeId, onTextSelect }) => {
            const [isRendering, setIsRendering] = useState(false);
            const containerRef = React.useRef(null);

            React.useEffect(() => {
                if (containerRef.current && content) {
                    setIsRendering(true);

                    // 延迟渲染以确保 DOM 已准备好
                    const timer = setTimeout(async () => {
                        try {
                            await ContentRenderer.renderContent(content, containerRef.current);
                            const container = containerRef.current;

                            // 简单的选择处理逻辑
                            const handleSelectionChange = () => {
                                // 清除所有现有的工具提示
                                const existingTooltips = document.querySelectorAll('.selection-tooltip');
                                existingTooltips.forEach(tooltip => tooltip.remove());

                                const selection = window.getSelection();
                                const selectedText = selection.toString().trim();

                                if (selectedText.length > 0) {
                                    try {
                                        const range = selection.getRangeAt(0);
                                        const rect = range.getBoundingClientRect();

                                        // 确保选择在当前容器内
                                        if (container.contains(range.commonAncestorContainer)) {
                                            createTooltip(rect, selectedText);
                                        }
                                    } catch (e) {
                                        console.error('Selection error:', e);
                                    }
                                }
                            };

                            const handleMouseUp = () => {
                                setTimeout(handleSelectionChange, 10);
                            };

                            // 添加事件监听器
                            container.addEventListener('mouseup', handleMouseUp);
                            document.addEventListener('selectionchange', handleSelectionChange);

                        } catch (error) {
                            console.error('Rendering error:', error);
                        } finally {
                            setIsRendering(false);
                        }
                    }, 50); // 增加延迟时间确保库已加载

                    return () => {
                        clearTimeout(timer);
                        setIsRendering(false);
                    };
                }
            }, [content, nodeId]);

            // 创建工具提示的简化函数
            const createTooltip = (rect, selectedText) => {
                const tooltipElement = document.createElement('div');
                tooltipElement.className = 'selection-tooltip';
                tooltipElement.innerHTML = '<i class="fas fa-search-plus"></i> 进一步解释';

                // 简单的位置计算
                const tooltipX = rect.left + (rect.width / 2) - 75;
                const tooltipY = rect.top - 45;

                tooltipElement.style.position = 'absolute';
                tooltipElement.style.left = `${tooltipX}px`;
                tooltipElement.style.top = `${tooltipY}px`;

                // 点击处理
                tooltipElement.onclick = (event) => {
                    event.stopPropagation();
                    console.log('Tooltip clicked for:', selectedText);

                    // 立即移除工具提示
                    tooltipElement.remove();

                    // 调用回调
                    if (onTextSelect) {
                        onTextSelect(selectedText.trim(), nodeId);
                    }
                };

                // 添加到文档
                document.body.appendChild(tooltipElement);
            };

            return (
                <div className="node-content" style={{ position: 'relative' }}>
                    {isRendering && <span className="content-rendering"></span>}
                    <div
                        ref={containerRef}
                        style={{ minHeight: isRendering ? '20px' : 'auto' }}
                    />
                </div>
            );
        };

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing libraries...');

            // 等待所有脚本加载完成
            setTimeout(() => {
                // 检查并初始化必要的库
                const libraries = {
                    'marked': typeof marked !== 'undefined',
                    'hljs': typeof hljs !== 'undefined',
                    'katex': typeof katex !== 'undefined',
                    'renderMathInElement': typeof renderMathInElement !== 'undefined'
                };

                console.log('=== Library Status Check ===');
                console.log('Library status:', libraries);

                // 检查必要的库是否已加载
                const missingLibraries = Object.entries(libraries)
                    .filter(([name, loaded]) => !loaded)
                    .map(([name]) => name);

                if (missingLibraries.length > 0) {
                    console.warn('❌ Missing libraries:', missingLibraries);
                } else {
                    console.log('✅ All libraries loaded successfully');
                }

                // 详细检查 KaTeX
                if (typeof katex !== 'undefined') {
                    console.log('KaTeX details:');
                    console.log('- version:', katex.version || 'unknown');
                    console.log('- renderToString available:', typeof katex.renderToString);
                    console.log('- render available:', typeof katex.render);
                }

                // 初始化 marked
                if (libraries.marked) {
                    try {
                        ContentRenderer.initMarked();
                        console.log('✅ Marked initialized successfully');
                    } catch (error) {
                        console.error('❌ Failed to initialize Marked:', error);
                    }
                } else {
                    console.error('❌ Marked library not available');
                }

                if (libraries.hljs) {
                    console.log('✅ Highlight.js available');
                } else {
                    console.warn('❌ Highlight.js not available');
                }

                if (libraries.katex) {
                    console.log('✅ KaTeX available');
                } else {
                    console.warn('❌ KaTeX not available');
                }

                if (libraries.renderMathInElement) {
                    console.log('✅ KaTeX auto-render available');
                } else {
                    console.warn('❌ KaTeX auto-render not available');
                }
                console.log('=== End Library Check ===');
            }, 200); // 增加等待时间确保脚本完全加载
        });

        // 作为备用方案，也在模块加载时尝试初始化
        if (typeof marked !== 'undefined') {
            ContentRenderer.initMarked();
        }

        // 知识节点组件
        const KnowledgeNode = ({ node, onExplore, onTextSelect, level = 0 }) => {
            const [isExpanded, setIsExpanded] = useState(true);

            const handleExplore = (content) => {
                const explorePrompt = `请详细解释这个知识点：${content}`;
                onExplore(explorePrompt, node.id);
            };

            const handleTextSelect = (selectedText, nodeId) => {
                const explainPrompt = `请详细解释以下内容：\n\n"${selectedText}"\n\n请提供深入的解释，包括相关概念、原理和应用场景。`;
                onExplore(explainPrompt, nodeId);
            };

            return (
                <div className="node">
                    <div className="node-header">
                        <div className={`node-type ${node.type}`}>
                            <i className={`fas fa-${node.type === 'question' ? 'question-circle' : 'lightbulb'}`}></i>
                            {node.type === 'question' ? '问题' : '回答'}
                        </div>
                        <div className="node-actions">
                            {node.type === 'answer' && (
                                <button
                                    className="node-action-btn"
                                    onClick={() => handleExplore(node.content)}
                                    title="进一步探索"
                                >
                                    <i className="fas fa-search"></i>
                                </button>
                            )}
                            <button
                                className="node-action-btn"
                                onClick={() => setIsExpanded(!isExpanded)}
                                title={isExpanded ? "折叠" : "展开"}
                            >
                                <i className={`fas fa-chevron-${isExpanded ? 'up' : 'down'}`}></i>
                            </button>
                        </div>
                    </div>

                    {isExpanded && (
                        <>
                            <RichContentRenderer
                            content={node.content}
                            nodeId={node.id}
                            onTextSelect={node.type === 'answer' ? handleTextSelect : null}
                        />
                            {node.tokens && (
                                <div className="token-info">
                                    输入令牌: {node.tokens.input} | 输出令牌: {node.tokens.output}
                                </div>
                            )}

                            {node.children && node.children.length > 0 && (
                                <div className="node-children">
                                    {node.children.map(child => (
                                        <KnowledgeNode
                                            key={child.id}
                                            node={child}
                                            onExplore={onExplore}
                                            onTextSelect={onTextSelect}
                                            level={level + 1}
                                        />
                                    ))}
                                </div>
                            )}
                        </>
                    )}
                </div>
            );
        };

        // 主应用组件
        const App = () => {
            const [systemMsg, setSystemMsg] = useState('你是一个专业的数学老师');
            const [modelId, setModelId] = useState('glm-4.5-air');
            const [isInitialized, setIsInitialized] = useState(true);
            const [isLoading, setIsLoading] = useState(false);
            const [status, setStatus] = useState({ type: 'info', message: 'AI助手已就绪' });
            const [rootNode, setRootNode] = useState(null);
            const [inputMessage, setInputMessage] = useState('');
            const [nodeIdCounter, setNodeIdCounter] = useState(1);

            // Conversation management state
            const [currentConversationId, setCurrentConversationId] = useState(null);
            const [conversations, setConversations] = useState([]);
            const [showConversations, setShowConversations] = useState(false);
            const [conversationTitle, setConversationTitle] = useState('');
            const [isEditingTitle, setIsEditingTitle] = useState(false);

            const showStatus = (type, message) => {
                setStatus({ type, message });
                setTimeout(() => setStatus(null), 5000);
            };

            // 测试KaTeX库的加载和功能
            const testKaTeX = () => {
                console.log('=== KaTeX Library Test ===');
                console.log('katex available:', typeof katex !== 'undefined');

                if (typeof katex !== 'undefined') {
                    console.log('katex object:', katex);
                    console.log('katex.renderToString available:', typeof katex.renderToString);
                    console.log('katex version:', katex.version || 'unknown');

                    // 测试简单公式
                    try {
                        const testFormulas = [
                            { formula: 'x = 1', display: false },
                            { formula: '\\int_0^1 x^2 dx', display: false },
                            { formula: '\\sum_{i=1}^n i = \\frac{n(n+1)}{2}', display: true }
                        ];

                        testFormulas.forEach(({ formula, display }) => {
                            try {
                                const result = katex.renderToString(formula, {
                                    displayMode: display,
                                    throwOnError: false
                                });
                                console.log(`✅ Formula "${formula}" rendered successfully:`, typeof result, result.substring(0, 100));
                            } catch (e) {
                                console.error(`❌ Formula "${formula}" failed:`, e);
                            }
                        });

                    } catch (error) {
                        console.error('KaTeX formula test failed:', error);
                    }
                } else {
                    console.error('❌ KaTeX is not loaded!');
                }
                console.log('=== End KaTeX Test ===');
            };

            // 测试渲染功能的函数
            const testRendering = () => {
                const testMarkdown = `# 测试 Markdown 渲染

这是一个**测试**，包含以下元素：

## 列表
1. 第一项
2. 第二项
3. 第三项

## 代码块
\`\`\`python
def hello_world():
    print("Hello, World!")
    return True
\`\`\`

## 内联代码
这里有一些内联代码：\`Q\`, \`x = 1\`, 和 \`函数()\`

## 数学公式
内联公式：$E = mc^2$

另一个内联公式：$x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$

块级公式：
$$\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}$$

积分公式：
$$\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}$$

## 格式文本
这是*斜体*和**粗体**文本。`;

                console.log('=== Testing markdown rendering ===');
                console.log('Input content:', testMarkdown);

                // 先测试KaTeX
                testKaTeX();

                try {
                    const html = ContentRenderer.renderMarkdown(testMarkdown);
                    console.log('Generated HTML type:', typeof html);
                    console.log('Generated HTML length:', html?.length);
                    console.log('Generated HTML (first 1000 chars):', html?.substring(0, 1000));

                    // 检查是否包含 [object Object]
                    if (html.includes('[object Object]')) {
                        console.warn('⚠️ Found [object Object] in rendered HTML!');
                        console.log('Matches:', html.match(/\[object Object\]/g));
                    } else {
                        console.log('✅ No [object Object] found in rendered HTML');
                    }

                    // 检查代码块是否正确渲染
                    if (html.includes('<pre data-language=')) {
                        console.log('✅ Code blocks rendered correctly');
                    } else {
                        console.warn('⚠️ Code blocks may not be rendered correctly');
                    }

                    // 检查内联代码是否正确渲染
                    if (html.includes('<code>Q</code>')) {
                        console.log('✅ Inline code rendered correctly');
                    } else {
                        console.warn('⚠️ Inline code may not be rendered correctly');
                    }

                    // 检查数学公式是否正确渲染
                    if (html.includes('katex')) {
                        console.log('✅ Math formulas rendered correctly');
                    } else {
                        console.warn('⚠️ Math formulas may not be rendered correctly');
                    }

                    alert('Markdown 渲染测试完成！请查看控制台输出了解详细信息。');
                } catch (error) {
                    console.error('Markdown 渲染测试失败:', error);
                    alert('Markdown 渲染测试失败：' + error.message);
                }
                console.log('=== End test ===');
            };

  
            // Conversation management functions
            const loadConversations = async () => {
                try {
                    const result = await api.getConversations();
                    if (result.success) {
                        setConversations(result.conversations);
                    }
                } catch (error) {
                    console.error('Failed to load conversations:', error);
                }
            };

            const loadConversation = async (conversationId) => {
                setIsLoading(true);
                try {
                    const result = await api.loadConversation(conversationId);
                    if (result.success) {
                        setIsInitialized(true);
                        setCurrentConversationId(conversationId);
                        setRootNode(result.conversation.tree);
                        setSystemMsg(result.conversation.system_msg);
                        setModelId(result.conversation.model_id);
                        setConversationTitle(result.conversation.title);
                        setShowConversations(false);
                        showStatus('success', '对话加载成功！');

                        // 刷新对话列表
                        loadConversations();
                    } else {
                        showStatus('error', `加载对话失败: ${result.error}`);
                    }
                } catch (error) {
                    showStatus('error', `网络错误: ${error.message}`);
                } finally {
                    setIsLoading(false);
                }
            };

            const deleteConversation = async (conversationId) => {
                if (!confirm('确定要删除这个对话吗？此操作不可撤销。')) {
                    return;
                }

                try {
                    const result = await api.deleteConversation(conversationId);
                    if (result.success) {
                        showStatus('success', '对话删除成功！');

                        // 如果删除的是当前对话，重置状态
                        if (conversationId === currentConversationId) {
                            handleReset();
                        }

                        // 刷新对话列表
                        loadConversations();
                    } else {
                        showStatus('error', `删除对话失败: ${result.error}`);
                    }
                } catch (error) {
                    showStatus('error', `网络错误: ${error.message}`);
                }
            };

            const updateTitle = async () => {
                if (!conversationTitle.trim()) {
                    showStatus('error', '标题不能为空');
                    return;
                }

                try {
                    const result = await api.updateConversationTitle(currentConversationId, conversationTitle.trim());
                    if (result.success) {
                        showStatus('success', '标题更新成功！');
                        setIsEditingTitle(false);
                        loadConversations();
                    } else {
                        showStatus('error', `更新标题失败: ${result.error}`);
                    }
                } catch (error) {
                    showStatus('error', `网络错误: ${error.message}`);
                }
            };

            // Load conversations on component mount
            React.useEffect(() => {
                loadConversations();
            }, []);

            const handleChat = async () => {
                if (!inputMessage.trim()) return;

                setIsLoading(true);
                try {
                    // 如果还没有对话ID，先初始化AI助手
                    if (!currentConversationId) {
                        const initResult = await api.initAgent(systemMsg, modelId);
                        if (!initResult.success) {
                            showStatus('error', `初始化失败: ${initResult.error}`);
                            return;
                        }
                        setCurrentConversationId(initResult.conversation_id);
                        showStatus('success', 'AI助手初始化成功！');
                        loadConversations();
                    }

                    const result = await api.chat(inputMessage);
                    if (result.success) {
                        // 使用后端返回的数据库节点ID和结构
                        const newNode = {
                            id: result.question_id,
                            type: 'question',
                            content: inputMessage,
                            children: [{
                                id: result.response.id,
                                type: 'answer',
                                content: result.response.content,
                                tokens: {
                                    input: result.response.input_tokens,
                                    output: result.response.output_tokens
                                },
                                children: []
                            }]
                        };

                        if (rootNode) {
                            setRootNode(prevRoot => addToTree(prevRoot, newNode));
                        } else {
                            setRootNode(newNode);
                        }
                        setInputMessage('');

                        // 刷新对话列表以更新时间戳
                        loadConversations();
                    } else {
                        showStatus('error', `对话失败: ${result.error}`);
                    }
                } catch (error) {
                    showStatus('error', `网络错误: ${error.message}`);
                } finally {
                    setIsLoading(false);
                }
            };

            const handleExplore = async (explorePrompt, parentNodeId) => {
                setIsLoading(true);
                try {
                    const result = await api.chat(explorePrompt, parentNodeId);
                    if (result.success) {
                        // 使用后端返回的数据库节点ID和结构
                        const exploreNode = {
                            id: result.question_id,
                            type: 'question',
                            content: explorePrompt,
                            children: [{
                                id: result.response.id,
                                type: 'answer',
                                content: result.response.content,
                                tokens: {
                                    input: result.response.input_tokens,
                                    output: result.response.output_tokens
                                },
                                children: []
                            }]
                        };

                        setRootNode(prevRoot => addToParent(prevRoot, parentNodeId, exploreNode));

                        // 刷新对话列表以更新时间戳
                        loadConversations();
                    } else {
                        showStatus('error', `探索失败: ${result.error}`);
                    }
                } catch (error) {
                    showStatus('error', `网络错误: ${error.message}`);
                } finally {
                    setIsLoading(false);
                }
            };

            const handleReset = async () => {
                setIsLoading(true);
                try {
                    const result = await api.resetAgent();
                    if (result.success) {
                        setRootNode(null);
                        setCurrentConversationId(result.conversation_id);
                        setConversationTitle('');
                        setIsEditingTitle(false);
                        showStatus('success', '对话已重置');

                        // 刷新对话列表
                        loadConversations();
                    } else {
                        showStatus('error', `重置失败: ${result.error}`);
                    }
                } catch (error) {
                    showStatus('error', `网络错误: ${error.message}`);
                } finally {
                    setIsLoading(false);
                }
            };

            const addToTree = (tree, newNode) => {
                return { ...newNode, children: [tree] };
            };

            const addToParent = (node, parentId, newNode) => {
                if (node.id === parentId) {
                    return { ...node, children: [...node.children, newNode] };
                }
                if (node.children) {
                    return {
                        ...node,
                        children: node.children.map(child => addToParent(child, parentId, newNode))
                    };
                }
                return node;
            };

            return (
                <div className="app">
                    <div className="header">
                        <h1>
                            <i className="fas fa-network-wired"></i>
                            Knode - 知识节点系统
                        </h1>
                        <button
                            onClick={testRendering}
                            style={{
                                background: '#667eea',
                                color: 'white',
                                border: 'none',
                                padding: '8px 16px',
                                borderRadius: '6px',
                                marginLeft: '20px',
                                cursor: 'pointer',
                                fontSize: '14px'
                            }}
                            title="测试 Markdown 渲染功能"
                        >
                            <i className="fas fa-vial"></i> 测试渲染
                        </button>
                    </div>

                    <div className="main-container">
                        <div className="sidebar">
                            <div className="model-selector">
                                <label>选择模型:</label>
                                <select value={modelId} onChange={(e) => setModelId(e.target.value)}>
                                    <option value="glm-4.6">GLM-4.6</option>
                                    <option value="glm-4.5">GLM-4.5</option>
                                    <option value="glm-4.5-air">GLM-4.5-Air</option>
                                    <option value="glm-4">GLM-4</option>
                                </select>
                            </div>

                            <div className="system-msg">
                                <label>系统消息:</label>
                                <textarea
                                    value={systemMsg}
                                    onChange={(e) => setSystemMsg(e.target.value)}
                                    placeholder="定义AI助手的角色和能力..."
                                />
                            </div>
  
                            {isInitialized && (
                                <div className="input-container">
                                    <button
                                        className="init-btn"
                                        onClick={handleReset}
                                        disabled={isLoading}
                                        style={{ marginTop: '10px' }}
                                    >
                                        <i className="fas fa-redo"></i>
                                        重置对话
                                    </button>
                                </div>
                            )}

                            {/* 对话管理部分 */}
                            <div className="conversation-section">
                                <div className="conversation-header">
                                    <h3>
                                        <i className="fas fa-history"></i>
                                        对话历史
                                    </h3>
                                    <button
                                        className="toggle-conversations-btn"
                                        onClick={() => setShowConversations(!showConversations)}
                                    >
                                        <i className={`fas fa-chevron-${showConversations ? 'up' : 'down'}`}></i>
                                    </button>
                                </div>

                                {showConversations && (
                                    <div className="conversation-list">
                                        {conversations.length > 0 ? (
                                            conversations.map(conv => (
                                                <div
                                                    key={conv.id}
                                                    className={`conversation-item ${conv.id === currentConversationId ? 'active' : ''}`}
                                                >
                                                    <div
                                                        className="conversation-info"
                                                        onClick={() => loadConversation(conv.id)}
                                                    >
                                                        <div className="conversation-title">{conv.title}</div>
                                                        <div className="conversation-meta">
                                                            {new Date(conv.updated_at).toLocaleDateString()} • {conv.model_id}
                                                        </div>
                                                    </div>
                                                    <div className="conversation-actions">
                                                        <button
                                                            className="conversation-action-btn load"
                                                            onClick={() => loadConversation(conv.id)}
                                                            title="加载对话"
                                                        >
                                                            <i className="fas fa-folder-open"></i>
                                                        </button>
                                                        <button
                                                            className="conversation-action-btn"
                                                            onClick={() => deleteConversation(conv.id)}
                                                            title="删除对话"
                                                        >
                                                            <i className="fas fa-trash"></i>
                                                        </button>
                                                    </div>
                                                </div>
                                            ))
                                        ) : (
                                            <div className="empty-conversations">
                                                暂无对话历史
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>

                            {/* 当前对话标题编辑 */}
                            {isInitialized && currentConversationId && (
                                <div className="conversation-section">
                                    <div className="conversation-title-section">
                                        <label style={{ fontSize: '14px', color: '#4a5568', margin: 0 }}>当前对话:</label>
                                        {isEditingTitle ? (
                                            <>
                                                <input
                                                    type="text"
                                                    className="conversation-title-input"
                                                    value={conversationTitle}
                                                    onChange={(e) => setConversationTitle(e.target.value)}
                                                    onKeyPress={(e) => e.key === 'Enter' && updateTitle()}
                                                    placeholder="输入对话标题"
                                                />
                                                <button
                                                    className="save-title-btn"
                                                    onClick={updateTitle}
                                                    disabled={!conversationTitle.trim()}
                                                >
                                                    保存
                                                </button>
                                                <button
                                                    className="cancel-edit-btn"
                                                    onClick={() => {
                                                        setIsEditingTitle(false);
                                                        // 重置为当前对话的标题
                                                        const currentConv = conversations.find(c => c.id === currentConversationId);
                                                        setConversationTitle(currentConv ? currentConv.title : '');
                                                    }}
                                                >
                                                    取消
                                                </button>
                                            </>
                                        ) : (
                                            <>
                                                <span style={{ flex: 1, fontSize: '14px', color: '#2d3748' }}>
                                                    {conversationTitle || '未命名对话'}
                                                </span>
                                                <button
                                                    className="edit-title-btn"
                                                    onClick={() => setIsEditingTitle(true)}
                                                    title="编辑标题"
                                                >
                                                    <i className="fas fa-edit"></i>
                                                </button>
                                            </>
                                        )}
                                    </div>
                                </div>
                            )}
                        </div>

                        <div className="tree-container">
                            {status && (
                                <div className={`status ${status.type}`}>
                                    {status.message}
                                </div>
                            )}

                            <div className="input-group">
                                    <input
                                        type="text"
                                        value={inputMessage}
                                        onChange={(e) => setInputMessage(e.target.value)}
                                        placeholder="输入你的问题..."
                                        onKeyPress={(e) => e.key === 'Enter' && handleChat()}
                                        disabled={isLoading}
                                    />
                                    <button
                                        onClick={handleChat}
                                        disabled={isLoading || !inputMessage.trim()}
                                    >
                                        {isLoading ? (
                                            <div className="loading">
                                                <div className="spinner"></div>
                                                思考中...
                                            </div>
                                        ) : (
                                            <>
                                                <i className="fas fa-paper-plane"></i>
                                                发送
                                            </>
                                        )}
                                    </button>
                                </div>
                            <div className="tree">
                                {rootNode ? (
                                    <KnowledgeNode
                                        node={rootNode}
                                        onExplore={handleExplore}
                                        onTextSelect={handleExplore}
                                    />
                                ) : (
                                    <div className="empty-state">
                                        <i className="fas fa-comments"></i>
                                        <p>开始你的第一个问题来构建知识树</p>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // 渲染应用
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>